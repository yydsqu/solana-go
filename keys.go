// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// Copyright 2021 github.com/gagliardetto
// This file has been modified by github.com/gagliardetto
//
// Copyright 2020 dfuse Platform Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package solana

import (
	"bytes"
	"crypto"
	"crypto/ed25519"
	crypto_rand "crypto/rand"
	"crypto/sha256"
	"errors"
	"fmt"
	"math"
	"os"
	"sort"

	"filippo.io/edwards25519"
	"github.com/mr-tron/base58"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/bsontype"
)

const PDA_MARKER = "ProgramDerivedAddress"

const (
	PublicKeyLength = 32
	MaxSeedLength   = 32
	MaxSeeds        = 16
	SignatureLength = 64
)

var (
	ZeroPublicKey = PublicKey{}
)

var (
	ErrMaxSeedLengthExceeded = errors.New("max seed length exceeded")
)

type PK = PublicKey

type PrivateKey []byte

// IsValid returns whether the private key is valid.
func (k PrivateKey) IsValid() bool {
	_, err := ValidatePrivateKey(k)
	return err == nil
}

func (k PrivateKey) Validate() error {
	_, err := ValidatePrivateKey(k)
	return err
}

func (k PrivateKey) String() string {
	return base58.Encode(k)
}

func (k PrivateKey) Sign(payload []byte) (Signature, error) {
	if err := k.Validate(); err != nil {
		return Signature{}, err
	}
	p := ed25519.PrivateKey(k)
	signData, err := p.Sign(crypto_rand.Reader, payload, crypto.Hash(0))
	if err != nil {
		return Signature{}, err
	}

	var signature Signature
	copy(signature[:], signData)

	return signature, err
}

func (k PrivateKey) PublicKey() PublicKey {
	if err := k.Validate(); err != nil {
		panic(err)
	}

	p := ed25519.PrivateKey(k)
	pub := p.Public().(ed25519.PublicKey)

	var publicKey PublicKey
	copy(publicKey[:], pub)

	return publicKey
}

func MustPrivateKeyFromBase58(in string) PrivateKey {
	out, err := PrivateKeyFromBase58(in)
	if err != nil {
		panic(err)
	}
	return out
}

func PrivateKeyFromBase58(privkey string) (PrivateKey, error) {
	res, err := base58.Decode(privkey)
	if err != nil {
		return nil, err
	}
	// validate
	if _, err := ValidatePrivateKey(res); err != nil {
		return nil, err
	}
	return res, nil
}

func ValidatePrivateKey(b []byte) (bool, error) {
	if len(b) != ed25519.PrivateKeySize {
		return false, fmt.Errorf("invalid private key size, expected %v, got %d", ed25519.PrivateKeySize, len(b))
	}
	// check if the public key is on the ed25519 curve
	pub := ed25519.PrivateKey(b).Public().(ed25519.PublicKey)
	if !IsOnCurve(pub) {
		return false, errors.New("the corresponding public key is NOT on the ed25519 curve")
	}
	return true, nil
}

func PrivateKeyFromSolanaKeygenFile(file string) (PrivateKey, error) {
	content, err := os.ReadFile(file)
	if err != nil {
		return nil, fmt.Errorf("read keygen file: %w", err)
	}
	return PrivateKeyFromSolanaKeygenFileBytes(content)
}

func PrivateKeyFromSolanaKeygenFileBytes(content []byte) (PrivateKey, error) {
	var values []byte
	err := json.Unmarshal(content, &values)
	if err != nil {
		return nil, fmt.Errorf("decode keygen file: %w", err)
	}
	// check private key length, should be 64 bytes (TODO: are private keys always 64 bytes?)
	if len(values) != 64 {
		return nil, fmt.Errorf("invalid private key length %d", len(values))
	}
	prk := PrivateKey([]byte(values))
	if _, err := ValidatePrivateKey(prk); err != nil {
		return nil, fmt.Errorf("invalid private key: %w", err)
	}
	return prk, nil
}

func NewRandomPrivateKey() (PrivateKey, error) {
	pub, priv, err := ed25519.GenerateKey(crypto_rand.Reader)
	if err != nil {
		return nil, err
	}
	var publicKey PublicKey
	copy(publicKey[:], pub)
	return PrivateKey(priv), nil
}

type PublicKey [PublicKeyLength]byte

func (p *PublicKey) MarshalText() ([]byte, error) {
	return []byte(base58.Encode(p[:])), nil
}

func (p *PublicKey) UnmarshalText(data []byte) error {
	return p.Set(string(data))
}

func (p *PublicKey) MarshalJSON() ([]byte, error) {
	return json.Marshal(base58.Encode(p[:]))
}

func (p *PublicKey) UnmarshalJSON(data []byte) (err error) {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*p, err = PublicKeyFromBase58(s)
	if err != nil {
		return fmt.Errorf("invalid public key %q: %w", s, err)
	}
	return
}

func (p PublicKey) MarshalBSON() ([]byte, error) {
	return bson.Marshal(p.String())
}

func (p *PublicKey) UnmarshalBSON(data []byte) (err error) {
	var s string
	if err := bson.Unmarshal(data, &s); err != nil {
		return err
	}

	*p, err = PublicKeyFromBase58(s)
	if err != nil {
		return fmt.Errorf("invalid public key %q: %w", s, err)
	}
	return nil
}

func (p PublicKey) MarshalBSONValue() (bsontype.Type, []byte, error) {
	return bson.MarshalValue(p.String())
}

func (p *PublicKey) UnmarshalBSONValue(t bsontype.Type, data []byte) (err error) {
	var s string
	if err := bson.UnmarshalValue(t, data, &s); err != nil {
		return err
	}

	*p, err = PublicKeyFromBase58(s)
	if err != nil {
		return fmt.Errorf("invalid public key %q: %w", s, err)
	}
	return nil
}

func (p PublicKey) Equals(pb PublicKey) bool {
	return p == pb
}

func (p PublicKey) IsAnyOf(keys ...PublicKey) bool {
	for _, k := range keys {
		if p.Equals(k) {
			return true
		}
	}
	return false
}

func (p PublicKey) ToPointer() *PublicKey {
	return &p
}

func (p PublicKey) Bytes() []byte {
	return p[:]
}

func (p PublicKey) IsOnCurve() bool {
	return IsOnCurve(p[:])
}

func (p PublicKey) Verify(message []byte, signature Signature) bool {
	pub := ed25519.PublicKey(p[:])
	return ed25519.Verify(pub, message, signature[:])
}

func (p PublicKey) IsZero() bool {
	return p == ZeroPublicKey
}

func (p *PublicKey) Set(s string) (err error) {
	*p, err = PublicKeyFromBase58(s)
	if err != nil {
		return fmt.Errorf("invalid public key %s: %w", s, err)
	}
	return
}

func (p PublicKey) String() string {
	return base58.Encode(p[:])
}

func (p PublicKey) Short(n int) string {
	return formatShortPubkey(n, p)
}

func PublicKeyFromBytes(in []byte) (out PublicKey) {
	byteCount := len(in)

	if byteCount != PublicKeyLength {
		panic(fmt.Errorf("invalid public key size, expected %v, got %d", PublicKeyLength, byteCount))
	}

	copy(out[:], in)
	return
}

func MPK(in string) PublicKey {
	return MustPublicKeyFromBase58(in)
}

func MustPublicKeyFromBase58(in string) PublicKey {
	out, err := PublicKeyFromBase58(in)
	if err != nil {
		panic(err)
	}
	return out
}

func PublicKeyFromBase58(in string) (out PublicKey, err error) {
	val, err := base58.Decode(in)
	if err != nil {
		return out, fmt.Errorf("decode: %w", err)
	}

	if len(val) != PublicKeyLength {
		return out, fmt.Errorf("invalid length, expected %v, got %d", PublicKeyLength, len(val))
	}

	copy(out[:], val)
	return
}

func formatShortPubkey(n int, pubkey PublicKey) string {
	str := pubkey.String()
	if n > (len(str)/2)-1 {
		n = (len(str) / 2) - 1
	}
	if n < 2 {
		n = 2
	}
	return str[:n] + "..." + str[len(str)-n:]
}

type PublicKeySlice []PublicKey

func (slice *PublicKeySlice) PublicKeys() PublicKeySlice {
	return *slice
}

func (slice *PublicKeySlice) UniqueAppend(pubkey PublicKey) bool {
	if !slice.Has(pubkey) {
		slice.Append(pubkey)
		return true
	}
	return false
}

func (slice *PublicKeySlice) Append(pubkeys ...PublicKey) {
	*slice = append(*slice, pubkeys...)
}

func (slice PublicKeySlice) Has(pubkey PublicKey) bool {
	for _, key := range slice {
		if key.Equals(pubkey) {
			return true
		}
	}
	return false
}

func (slice PublicKeySlice) Len() int {
	return len(slice)
}

func (slice PublicKeySlice) Less(i, j int) bool {
	return bytes.Compare(slice[i][:], slice[j][:]) < 0
}

func (slice PublicKeySlice) Swap(i, j int) {
	slice[i], slice[j] = slice[j], slice[i]
}

// Sort sorts the slice.
func (slice PublicKeySlice) Sort() {
	sort.Sort(slice)
}

func (slice PublicKeySlice) Dedupe() PublicKeySlice {
	slice.Sort()
	deduped := make(PublicKeySlice, 0)
	for i := 0; i < len(slice); i++ {
		if i == 0 || !slice[i].Equals(slice[i-1]) {
			deduped = append(deduped, slice[i])
		}
	}
	return deduped
}

func (slice PublicKeySlice) Contains(pubkey PublicKey) bool {
	for _, key := range slice {
		if key.Equals(pubkey) {
			return true
		}
	}
	return false
}

func (slice PublicKeySlice) ContainsAll(pubkeys PublicKeySlice) bool {
	for _, pubkey := range pubkeys {
		if !slice.Contains(pubkey) {
			return false
		}
	}
	return true
}

func (slice PublicKeySlice) ContainsAny(pubkeys ...PublicKey) bool {
	for _, pubkey := range pubkeys {
		if slice.Contains(pubkey) {
			return true
		}
	}
	return false
}

func (slice PublicKeySlice) ToBase58() []string {
	out := make([]string, len(slice))
	for i, pubkey := range slice {
		out[i] = pubkey.String()
	}
	return out
}

func (slice PublicKeySlice) ToBytes() [][]byte {
	out := make([][]byte, len(slice))
	for i, pubkey := range slice {
		out[i] = pubkey.Bytes()
	}
	return out
}

func (slice PublicKeySlice) ToPointers() []*PublicKey {
	out := make([]*PublicKey, len(slice))
	for i, pubkey := range slice {
		out[i] = pubkey.ToPointer()
	}
	return out
}

func (a PublicKeySlice) Removed(b PublicKeySlice) PublicKeySlice {
	var diff PublicKeySlice
	for _, pubkey := range a {
		if !b.Contains(pubkey) {
			diff = append(diff, pubkey)
		}
	}
	return diff.Dedupe()
}

func (a PublicKeySlice) Added(b PublicKeySlice) PublicKeySlice {
	return b.Removed(a)
}

func (prev PublicKeySlice) Intersect(next PublicKeySlice) PublicKeySlice {
	var intersect PublicKeySlice
	for _, pubkey := range prev {
		if next.Contains(pubkey) {
			intersect = append(intersect, pubkey)
		}
	}
	return intersect.Dedupe()
}

func (slice PublicKeySlice) Equals(other PublicKeySlice) bool {
	if len(slice) != len(other) {
		return false
	}
	for i, pubkey := range slice {
		if !pubkey.Equals(other[i]) {
			return false
		}
	}
	return true
}

func (slice PublicKeySlice) Same(other PublicKeySlice) bool {
	if len(slice) != len(other) {
		return false
	}
	for _, pubkey := range slice {
		if !other.Contains(pubkey) {
			return false
		}
	}
	return true
}

func (slice PublicKeySlice) Split(chunkSize int) []PublicKeySlice {
	divided := make([]PublicKeySlice, 0)
	if len(slice) == 0 || chunkSize < 1 {
		return divided
	}
	if len(slice) == 1 {
		return append(divided, slice)
	}

	for i := 0; i < len(slice); i += chunkSize {
		end := i + chunkSize

		if end > len(slice) {
			end = len(slice)
		}

		divided = append(divided, slice[i:end])
	}

	return divided
}

func (slice PublicKeySlice) Last() *PublicKey {
	if len(slice) == 0 {
		return nil
	}
	return slice[len(slice)-1].ToPointer()
}

func (slice PublicKeySlice) First() *PublicKey {
	if len(slice) == 0 {
		return nil
	}
	return slice[0].ToPointer()
}

func (prev PublicKeySlice) GetAddedRemoved(next PublicKeySlice) (added PublicKeySlice, removed PublicKeySlice) {
	return next.Removed(prev), prev.Removed(next)
}

func GetAddedRemovedPubkeys(previous PublicKeySlice, next PublicKeySlice) (added PublicKeySlice, removed PublicKeySlice) {
	added = make(PublicKeySlice, 0)
	removed = make(PublicKeySlice, 0)

	for _, prev := range previous {
		if !next.Has(prev) {
			removed = append(removed, prev)
		}
	}

	for _, nx := range next {
		if !previous.Has(nx) {
			added = append(added, nx)
		}
	}

	return
}

func CreateWithSeed(base PublicKey, seed string, owner PublicKey) (PublicKey, error) {
	if len(seed) > MaxSeedLength {
		return PublicKey{}, ErrMaxSeedLengthExceeded
	}
	b := make([]byte, 0, 64+len(seed))
	b = append(b, base[:]...)
	b = append(b, seed[:]...)
	b = append(b, owner[:]...)
	hash := sha256.Sum256(b)
	return PublicKeyFromBytes(hash[:]), nil
}

func CreateProgramAddress(seeds [][]byte, programID PublicKey) (PublicKey, error) {
	if len(seeds) > MaxSeeds {
		return PublicKey{}, ErrMaxSeedLengthExceeded
	}

	for _, seed := range seeds {
		if len(seed) > MaxSeedLength {
			return PublicKey{}, ErrMaxSeedLengthExceeded
		}
	}

	buf := []byte{}
	for _, seed := range seeds {
		buf = append(buf, seed...)
	}

	buf = append(buf, programID[:]...)
	buf = append(buf, []byte(PDA_MARKER)...)
	hash := sha256.Sum256(buf)

	if IsOnCurve(hash[:]) {
		return PublicKey{}, errors.New("invalid seeds; address must fall off the curve")
	}

	return PublicKeyFromBytes(hash[:]), nil
}

func IsOnCurve(b []byte) bool {
	if len(b) != ed25519.PublicKeySize {
		return false
	}
	_, err := new(edwards25519.Point).SetBytes(b)
	return err == nil
}

func FindProgramAddress(seed [][]byte, programID PublicKey) (PublicKey, uint8, error) {
	var address PublicKey
	var err error
	bumpSeed := uint8(math.MaxUint8)
	for bumpSeed != 0 {
		address, err = CreateProgramAddress(append(seed, []byte{byte(bumpSeed)}), programID)
		if err == nil {
			return address, bumpSeed, nil
		}
		bumpSeed--
	}
	return PublicKey{}, bumpSeed, errors.New("unable to find a valid program address")
}

func FindAssociatedTokenAddress(wallet PublicKey, mint PublicKey) (PublicKey, uint8, error) {
	return findAssociatedTokenAddressAndBumpSeed(
		wallet,
		mint,
		SPLAssociatedTokenAccountProgramID,
	)
}

func findAssociatedTokenAddressAndBumpSeed(walletAddress PublicKey, splTokenMintAddress PublicKey, programID PublicKey) (PublicKey, uint8, error) {
	return FindProgramAddress([][]byte{
		walletAddress[:],
		TokenProgramID[:],
		splTokenMintAddress[:],
	},
		programID,
	)
}

func FindTokenMetadataAddress(mint PublicKey) (PublicKey, uint8, error) {
	seed := [][]byte{
		[]byte("metadata"),
		TokenMetadataProgramID[:],
		mint[:],
	}
	return FindProgramAddress(seed, TokenMetadataProgramID)
}

func GetAssociatedAuthority(programID PublicKey, marketAddr PublicKey) (PublicKey, uint8, error) {
	var address PublicKey
	var err error
	bumpSeed := uint8(0)
	endSeed := []byte{0, 0, 0, 0, 0, 0, 0}
	for bumpSeed < 100 {
		address, err = CreateProgramAddress([][]byte{marketAddr[:], {byte(bumpSeed)}, endSeed}, programID)
		if err == nil {
			return address, bumpSeed, nil
		}
		bumpSeed++
	}
	return PublicKey{}, bumpSeed, errors.New("unable to find a valid program address")
}
